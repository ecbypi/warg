#!/usr/bin/env ruby

require "simplecov"
SimpleCov.start do
  add_filter %r{^/(?:warg|test)/}
  # For running on ruby 2.3 on CI. Latest simplecov requires ruby 2.4+ and `enable_coverage`
  # only exists on the latest versions
  respond_to?(:enable_coverage) and enable_coverage(:branch)

  # Combine coverage results generated here to what's generated by the test suite
  command_name "Unit Tests"
end

$:.unshift(File.expand_path(File.join("..", "..", "lib"), __FILE__))

if ENV["BYEBUG_REMOTE"] == "1"
  require "byebug"
  require "byebug/core"
  Byebug.wait_connection = true
  Byebug.start_server("localhost", 5000)
end

require "pry"

# NOTE: Unsure why `"set"` needs to be loaded here
require "set"
require "warg"

console = Warg::Console.new

ctpa_town = Warg::Host.from("randy@ctpa-town.com")
sodo_sopa = Warg::Host.from("loo@sodo-sopa.com")
nomo_auchi = Warg::Host.from("pc@nomo-auchi.com")
lomo_robo = Warg::Host.from("luke@lomo-robo.com")

Warg::Console.hostname_width = [ctpa_town, sodo_sopa, nomo_auchi].map { |host| host.address.length }.max

console.redirecting_stdout_and_stderr do
  # `mirame` is an example of content spanning multiple lines with its last line being longer
  # than 0.
  mirame = console.print_content "mirame!\n ahora! "

  # We follow `mirame` with content on the same line; when we reset `mirame` to empty text later,
  # this ensures content is correctly reflowed
  console.print Warg::Console::SGR("buscame?").with(text_color: :green, effect: :underline)

  sleep 2

  # Add a `HostStatus` to check that changing host status after multi-line and single-line content
  # works as expected
  host_line_1 = Warg::Console::HostStatus.new(ctpa_town, console)

  sleep 2

  # Start a line with single-line content
  que_tal = console.print_content "que tal "

  sleep 2

  # Add a `HostStatus`
  host_line_2 = Warg::Console::HostStatus.new(sodo_sopa, console)

  sleep 2

  # Reset `mirame` to an empty string with SGR effects to check SGR sequences don't affect the
  # `last_line_length` of the content
  mirame.text = Warg::Console::SGR("").with(text_color: :cyan, effect: :strikethrough)

  sleep 2

  # Update the status of `host_line_1` to check that content after it is re-printed correctly
  host_line_1.started!

  sleep 2

  # Add content using `Kernel#print` and `IOProxy#print` to test `IOProxy`
  print "no me cambies! "
  $stdout.print Warg::Console::SGR("dejame aqui! ").with(text_color: :red, effect: :blink_slow)

  # Add more inline content
  que_haces = console.print_content "que haces? "

  sleep 2

  # Add two host statuses
  host_line_3 = Warg::Console::HostStatus.new(nomo_auchi, console)

  sleep 2

  host_line_4 = Warg::Console::HostStatus.new(lomo_robo, console)

  $stdout.puts "me quedo aqui abajo"

  sleep 2

  # Change text so it is longer to check that content after it is reflowed correctly
  que_tal.text = "que fue mijo?! "

  sleep 2

  host_line_4.started!

  sleep 2

  host_line_2.failed! <<~CONTENT
  STDOUT: (none)
  STDERR: unbound variable `$der'
  CONTENT

  sleep 2

  que_haces.text = Warg::Console::SGR("cuanto quieres? ").with(text_color: :magenta)

  sleep 2

  host_line_3.failed! <<~CONTENT
  STDOUT: (none)
  STDERR: whoopsie!
  CONTENT

  sleep 2

  host_line_4.success!
end
